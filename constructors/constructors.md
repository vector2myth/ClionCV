## 简单工厂模式
> 关注对象的创建过程，让用户在对象使用过程中无须关心对象的创建细节，从而降低系统耦合度，易于修改和扩展
>> 定义一个简单工厂类，可以根据参数的不同返回不同类的实例，被创建的实例通常都具有相同的父类
+ 有三种角色
> 工厂Factory：根据客户提供的具体产品类的修改，创建具体产品实例；<br>
> 抽象产品Abstract Product：具体产品类的基类，包含创建产品的公共方法；<br>
> 具体产品Concrete Product：抽象产品的派生类，包含具体产品特有的实现方法。<br>
+ 简单工厂模式的优点
  + 工厂提供创建具体产品的方法，可不不必参与产品的创建过程
  + 客户只需要对应产品的参数即可
+ 简单工厂模式的缺点
  + **违背了开闭原则**，即对扩展开放、对修改关闭，简单工厂在扩展时就会修改既有的代码
  + 所有的判断逻辑都在工厂类中实现，**一旦工厂类出现逻辑错误**，所有的产品都会受到影响
---
`shared_ptr和make_ptr的用法`：
- 前提：
>在程序设计过程中，要开启一个不知道大小的内存空间，这个空间会根据所需大小改变，这就是动态内存
+ 用法：
> shared_ptr，可以指向特定类型的对象，用于自动释放所指的对象
make_shared，在动态内存中分配一个对象并初始化，返回此对象指向的shared_ptr
头文件#include<memory>
---
虚函数virtual方法的使用场景：父类告诉子类，继承接口，修改实现，从而可以面向接口编程。
~析构函数，在对象创建结束之后使用
---
## 工厂方法模式
>定义一个用于创建其他对象的接口，但是让子类决定将哪一个类实例化。
>>对简单工厂方法的进一步抽象化，满足了"开闭原则"
+ 有四个角色
>抽象工厂Abstract Factory：提供了创建产品的接口；<br>
>具体工厂Concrete Factory：主要实现了抽象工厂中的抽象方法，完成具体产品的创建;<br>
>抽象产品Abstract Product：定义了产品的规范，描述了产品的主要特征和性能；<br>
>具体产品Concrete Product：实现了抽象产品所定义的接口，由具体工厂来创建，它与具体工厂之间一一对应。
+ 优点
  + 用户只需要具体工厂的名称就可以得到所要的产品，无须知道产品的具体创建过程；<br>
  + 灵活性强，对于新产品的创建，只要多写一个相应的工厂类，无须修改原有代码，增强了系统的可扩展性；<br>
+ 缺点
  + 类的个数容易过多，增加复杂度；<br>
  + 增加了系统的抽象性和理解难度；<br>
  + 抽象产品只能生产一种产品，_此弊端可使用抽象工厂模式解决_。<br>
+ 应用场景
  + 客户端不需要知道它所需要创建的对象的类；<br>
  + 抽象工厂类通过其子类来指定创建哪个对象（运用多态性设计和里氏代换原则）。<br>
---
  